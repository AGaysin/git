###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.40.1.50106 for STM8             23/Jun/2015  14:12:17 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\Drive\1503_RFID-DALLAS\STM8S103F3\Project\Discover\sr #
#                    c\main.c                                                 #
#    Command line =  D:\Drive\1503_RFID-DALLAS\STM8S103F3\Project\Discover\sr #
#                    c\main.c -e -On --no_cse --no_unroll --no_inline         #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model small --data_model medium -o                #
#                    D:\Drive\1503_RFID-DALLAS\STM8S103F3\Debug\Obj\          #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5_2\stm8\LIB\dlstm8smn.h"   #
#                    -lc D:\Drive\1503_RFID-DALLAS\STM8S103F3\Debug\List\ -I  #
#                    D:\Drive\1503_RFID-DALLAS\STM8S103F3\Libraries\STM8_Touc #
#                    hSensing_Driver\inc\ -I D:\Drive\1503_RFID-DALLAS\STM8S1 #
#                    03F3\Libraries\STM8S_StdPeriph_Driver\inc\ -I            #
#                    D:\Drive\1503_RFID-DALLAS\STM8S103F3\Project\Discover\in #
#                    c\ --vregs 16                                            #
#    List file    =  D:\Drive\1503_RFID-DALLAS\STM8S103F3\Debug\List\main.lst #
#    Object file  =  D:\Drive\1503_RFID-DALLAS\STM8S103F3\Debug\Obj\main.o    #
#                                                                             #
#                                                                             #
###############################################################################

D:\Drive\1503_RFID-DALLAS\STM8S103F3\Project\Discover\src\main.c
      1          /**
      2            ******************************************************************************
      3            * @file STM8_main.c
      4            * @brief RC Touch Sensing Library for STM8 CPU family.
      5            * Application example.
      6            * @author STMicroelectronics - MCD Application Team
      7            * @version V0.2.0
      8            * @date 19-DEC-2008
      9            ******************************************************************************
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2008 STMicroelectronics</center></h2>
     19            * @image html logo.bmp
     20            ******************************************************************************
     21            */
     22          
     23          
     24          /*RELEASE V.1.2
     25          
     26          
     27          
     28          
     29          Увеличили время определения кода 33 tRL=25us было 15us
     30          на считывателе Z5R код 33h не успевал считываться и получалось 00h
     31          
     32          
     33          */
     34          
     35          
     36          /*RELEASE V.1.1
     37          
     38          
     39          
     40          
     41          ДЛЯ МОСТОВОЙ СХЕМЫ НА 74AC02/74AC04
     42          
     43          Частота генерации длиться 75мс, 250мс выключает генерацию для экономи потребления
     44          Если в поле зрения попадает карта - продливает генерацию на 75мс каждый считанные импульс
     45          
     46          
     47          */
     48          
     49          
     50          /* RELEASE V.1.0
     51          DATE: 13.04.2015
     52          FILE: STM8S103F3P6_RFID_V1.0.hex
     53          CPU: STM8S103F3P6
     54          DEV: AG, John
     55          PCB: RF-1W ver. 1.0.pcb
     56          VCC: 12V
     57          ICC: 20-30mA
     58          
     59          Постоянная генерация выхода 125кГц,
     60          Оптимизирована работа компаратора
     61          
     62          Вначале ждет считывание RFID, проверяет проверки четности и контрольной суммы, как только считанные данные верные - начинает передачу кода в TM
     63          При этом передача кода в TM идет на каждый запрос, пока в поле зрения есть карта.
     64          
     65          
     66          */
     67          
     68          
     69          /* Includes ------------------------------------------------------------------*/
     70          #include "stm8s.h"
     71          #include "stm8s_tim1.h"
     72          #include "stm8s_tim2.h"
     73          #include "stm8s_adc1.h"
     74          #include "stm8s_itc.h"
     75          #include "stm8s_tim4.h"
     76          #include "stm8s_exti.h"
     77          #include "intrinsics.h" 
     78          #include "stm8s_iwdg.h"
     79          
     80          
     81          
     82          /* Private typedef -----------------------------------------------------------*/
     83          /* Private define ------------------------------------------------------------*/
     84          #define MilliSec       1
     85          #define Sec           10
     86          /* Private macro -------------------------------------------------------------*/
     87          /* Private variables ---------------------------------------------------------*/
     88          /* Private function prototypes -----------------------------------------------*/
     89          void CLK_Configuration(void);
     90          void GPIO_Configuration(void);
     91          void TIM1_Configuration(void);
     92          void TIM2_Configuration(void);
     93          void TIM4_Configuration(void);
     94          
     95          void IWDG_Configuration(void);
     96          
     97          unsigned char CRC8( unsigned char *mas, unsigned char Len );
     98          unsigned char RFID_crc8;
     99          void ADC_Configuration(void);
    100          
    101          unsigned char RFID_FindStart(void);
    102          void RFID_GetData(void);
    103          void RFID_Reset(void);
    104          
    105          unsigned char OWTM_Request(void);
    106          unsigned char OWTM_SendData(unsigned char *OW_DataBuffer);
    107          void BuzzerChirp(void);
    108          void BuzzerStart(void);
    109          void BuzzerSound(unsigned int freq, unsigned int delay);
    110          
    111          
    112          unsigned char ucDataByte, ucDataBit, ucRowParity=0;
    113          unsigned char ucStringParity=0;
    114          /* Private functions ---------------------------------------------------------*/
    115          
    116          /* Global variables ----------------------------------------------------------*/
    117          
    118          unsigned int uiRfidFreqCnt=0;
    119          unsigned char isRfidFreqStart=0;
    120          unsigned char isRfidFreqStop=0;
    121          unsigned char isRfedFreqEnable=0;
    122          
    123          
    124          unsigned char ucDataReceiveIndex=0;
    125          unsigned char ucDataReceiveBuffer[11];
    126          
    127          unsigned char ucOldKeyCode[11];
    128          unsigned char ucCnt=0;
    129          unsigned int uiKeyCodeResetTimer=0;
    130          unsigned char ucDuration=0;
    131          unsigned char ucDurationFlag=0;
    132          unsigned char ucEdgeCounter=0;
    133          unsigned char flagEnableTM_DisableRFID=0;
    134          unsigned char ucInputLevel=0;
    135          
    136          unsigned int uiRfidPulsesCounter=0;
    137          unsigned char flagRfidKeyCodeReady=0;
    138          unsigned char flagRfidKeyCodeSendOk=0;
    139          
    140          unsigned char uiOWCountEnable=0;
    141          unsigned int uiOWTimer;
    142          unsigned char flagRfidPinOldState=0;
    143          
    144          
    145          
    146          unsigned char ucTestMaxStartCounter=0;
    147          /* Public functions ----------------------------------------------------------*/
    148          __interrupt void EMMarineDataReceive(void);
    149          /**
    150            ******************************************************************************
    151            * @brief Main function.
    152            * @par Parameters:
    153            * None
    154            * @retval void None
    155            * @par Required preconditions:
    156            * None
    157            ******************************************************************************
    158            */
    159          
    160          /* FIRST MAKET VERSION 
    161          
    162          #define EM_MARINE_READ_INPUT GPIO_ReadInputPin(GPIOC, GPIO_PIN_4)
    163          
    164          #define TM_READ_INPUT GPIO_ReadInputPin(GPIOA, GPIO_PIN_3)
    165          
    166          #define TM_PULL_DOWN GPIO_WriteHigh(GPIOC,GPIO_PIN_7);
    167          
    168          #define TM_PULL_UP GPIO_WriteLow(GPIOC,GPIO_PIN_7);
    169          */
    170          
    171          
    172          
    173          #define EM_MARINE_READ_INPUT GPIO_ReadInputPin(GPIOA, GPIO_PIN_3)
    174          
    175          //#define TM_READ_INPUT GPIO_ReadInputPin(GPIOC, GPIO_PIN_3)
    176          
    177          //#define TM_PULL_DOWN 
    178          
    179          //#define TM_PULL_UP GPIO_WriteLow(GPIOC,GPIO_PIN_4);
    180          
    181          #define TEST_ON GPIO_WriteHigh(GPIOD,GPIO_PIN_4);
    182          #define TEST_OFF GPIO_WriteLow(GPIOD,GPIO_PIN_4);
    183          #define TEST_REVERSE GPIO_WriteReverse(GPIOD,GPIO_PIN_4);
    184          
    185          void main(void)
    186          {
    187            /* Configures clocks */
    188            CLK_Configuration();
    189          
    190            /* Configures GPIOs */
    191            GPIO_Configuration();
    192            GPIO_WriteLow(GPIOC,GPIO_PIN_4);
    193            
    194          
    195            //PWM 125kHz clock gen
    196            TIM2_Configuration();
    197            //ADC_Configuration();
    198            TIM4_Configuration();
    199            /* Configures External Interrupts */
    200            //PC4 interrupt
    201            //EXTI_SetExtIntSensitivity(EXTI_PORT_GPIOC,EXTI_SENSITIVITY_RISE_ONLY);
    202            //EXTI_SetExtIntSensitivity(EXTI_PORT_GPIOA,EXTI_SENSITIVITY_RISE_FALL);
    203            //EXTI_SetTLISensitivity(EXTI_TLISENSITIVITY_FALL_ONLY);
    204          
    205            //TM Timer
    206            //TIM1_Configuration();
    207            
    208            
    209          
    210            /* enable interrupts */
    211            BuzzerStart();
    212            
    213            IWDG_Configuration();
    214            
    215            enableInterrupts();
    216          
    217          
    218            
    219            for (;;)
    220            {
    221          
    222              //RFID 125 kHz GENERATION START
    223             /*if (isRfidFreqStart) 
    224              {
    225                isRfidFreqStart = 0;
    226                isRfedFreqEnable = 1;
    227                TIM2_Configuration();
    228              }
    229              //RFID 125 kHz GENERATION STOP
    230              if (isRfidFreqStop)
    231              {
    232                isRfidFreqStop = 0;
    233                isRfedFreqEnable = 0;
    234                TIM2_DeInit();
    235              }
    236              
    237              */
    238              
    239              if (flagRfidKeyCodeReady)
    240              {
    241                //Запрещаем прерывания
    242                disableInterrupts();
    243                //Тестовый светик, горит = читает RFID, не горит - передает TM
    244                //GPIO_WriteLow(GPIOB, GPIO_PIN_5);
    245                while(++uiRfidPulsesCounter < 1500)
    246                {
    247                  IWDG_ReloadCounter(); //Wath-dog reset
    248                  
    249                  //Проверка импульсов на входе RFID
    250                  if (EM_MARINE_READ_INPUT) uiRfidPulsesCounter = 0;
    251                  
    252                  //Ждем низкого уровня, импульса RESET
    253                  if (!GPIO_ReadInputPin(GPIOC, GPIO_PIN_3)) 
    254                  {
    255                    if (OWTM_SendData(ucDataReceiveBuffer)) 
    256                    {
    257                      if (flagRfidKeyCodeSendOk)
    258                      {
    259                        flagRfidKeyCodeSendOk = 0;
    260                        //Chirp <- WDR inside
    261                        BuzzerChirp();
    262                        uiRfidPulsesCounter=0;
    263                      }
    264                    }
    265                  }
    266                }
    267                //Разрешение прерываний
    268                enableInterrupts();
    269                //Переключение на RFID
    270                flagRfidKeyCodeReady = 0;
    271                //Сброс параметров RFID
    272                RFID_Reset();
    273              }
    274              else //RFID CODE READING
    275              {
    276                //Wath-dog reset
    277                IWDG_ReloadCounter();
    278                //Тестовый светик, горит = читает RFID, не горит - передает TM
    279                //GPIO_WriteHigh(GPIOB, GPIO_PIN_5);
    280                if (EM_MARINE_READ_INPUT && !ucInputLevel)
    281                {
    282                  //Продливаем тактирование RFID на 70мкс
    283                  uiRfidFreqCnt = 1;
    284                  //Rise edge
    285                  ucInputLevel = 1;
    286                  if (RFID_FindStart()) RFID_GetData();
    287                }
    288                else if (!EM_MARINE_READ_INPUT && ucInputLevel)
    289                {
    290                  //Продливаем тактирование RFID на 70мкс
    291                  uiRfidFreqCnt = 1;
    292                  //Fall edge
    293                  ucInputLevel = 0;
    294                  if (RFID_FindStart()) RFID_GetData();
    295                }
    296              }
    297            }
    298          }
    299          
    300          
    301          void CLK_Configuration(void)
    302          {
    303          
    304            /* Fmaster = 16MHz */
    305            CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);
    306          
    307          }
    308          
    309          void GPIO_Configuration(void)
    310          {
    311            /* GPIOD reset */
    312            GPIO_DeInit(GPIOD);
    313            GPIO_DeInit(GPIOA);
    314            GPIO_DeInit(GPIOB);
    315          
    316            
    317            //PD3 - TIM2-CH2 - 125kHz - PWM 50%
    318            GPIO_Init(GPIOD, GPIO_PIN_3, GPIO_MODE_OUT_PP_HIGH_FAST);
    319            
    320            //PD2 - BUZZER output, Push-Pull
    321            //GPIO_Init(GPIOD, GPIO_PIN_2, GPIO_MODE_OUT_PP_LOW_FAST);
    322            
    323            /*FIRST MAKET VERSION 
    324            //PC4 - EM-MARINE DATA INPUT PIN, Ext. Interrupt 
    325            GPIO_Init(GPIOC, GPIO_PIN_4, GPIO_MODE_IN_FL_NO_IT);
    326            
    327            //PA3 - TM INPUT, 
    328            GPIO_Init(GPIOA, GPIO_PIN_3, GPIO_MODE_IN_FL_NO_IT);
    329            
    330            //PC7 - TM OUTPUT PushPull 
    331            GPIO_Init(GPIOC, GPIO_PIN_7, GPIO_MODE_OUT_PP_HIGH_FAST);
    332          */
    333            
    334            //PA3 - EM-MARINE DATA INPUT PIN, Ext. Interrupt 
    335            GPIO_Init(GPIOA, GPIO_PIN_3, GPIO_MODE_IN_FL_NO_IT);
    336            
    337            //PC3 - TM INPUT, 
    338            GPIO_Init(GPIOC, GPIO_PIN_3, GPIO_MODE_IN_FL_NO_IT);
    339            
    340            //PC4 - TM OUTPUT PushPull 
    341            GPIO_Init(GPIOC, GPIO_PIN_4, GPIO_MODE_OUT_PP_HIGH_FAST);
    342            
    343            //PD4 - LED TEST out OD
    344            GPIO_Init(GPIOD, GPIO_PIN_4, GPIO_MODE_OUT_PP_HIGH_FAST);
    345            //PB4 - LED TEST out OD
    346           //GPIO_Init(GPIOB, GPIO_PIN_4, GPIO_MODE_OUT_OD_LOW_FAST);
    347            
    348            
    349            
    350            //PC5 - BUZZER+ OUTPUT PushPull 
    351            GPIO_Init(GPIOC, GPIO_PIN_5, GPIO_MODE_OUT_PP_HIGH_FAST);
    352            //PC6 - BUZZER- OUTPUT PushPull 
    353            GPIO_Init(GPIOC, GPIO_PIN_6, GPIO_MODE_OUT_PP_HIGH_FAST);
    354           
    355          
    356          }
    357          
    358          void TIM1_Configuration(void)
    359          {
    360            /* TIM1 Peripheral Configuration */ 
    361            TIM1_DeInit();
    362          
    363            /* Time Base configuration */
    364          	/*
    365            TIM1_Prescaler = 0
    366            TIM1_CounterMode = TIM1_COUNTERMODE_UP
    367            TIM1_Period = 65535
    368            TIM1_RepetitionCounter = 0
    369            
    370          	*/
    371          
    372            TIM1_TimeBaseInit(0, TIM1_COUNTERMODE_UP, 6000,0); //370us
    373            
    374            /* Clear TIM4 update flag */
    375            TIM1_ClearFlag(TIM1_FLAG_UPDATE);
    376            /* Enable update interrupt */
    377            TIM1_ITConfig(TIM1_IT_UPDATE, ENABLE);
    378            
    379            /* TIM1 counter enable */
    380            TIM1_Cmd(ENABLE);
    381          }
    382          
    383          void TIM2_Configuration(void)
    384          {
    385            TIM2_DeInit();
    386            TIM2_TimeBaseInit(TIM2_PRESCALER_1, 127);
    387            TIM2_OC2Init(TIM2_OCMODE_PWM2, TIM2_OUTPUTSTATE_ENABLE,64, TIM2_OCPOLARITY_LOW);
    388            //TIM2_ARRPreloadConfig(ENABLE);
    389            //TIM2_OC2PreloadConfig(ENABLE);
    390            //TIM2_SetCompare2(uiRfidOutFrequency);
    391            //TIM2_SetAutoreload(2*uiRfidOutFrequency-1);
    392            //if (uiRfidOutFrequency<100)uiRfidOutFrequency++;
    393            //else TIM2_DeInit();
    394            /* Clear TIM2 update flag */
    395            //TIM2_ClearFlag(TIM2_FLAG_CC2);
    396            /* Enable update interrupt */
    397            //TIM2_ITConfig(TIM2_IT_CC2, ENABLE);
    398            TIM2_Cmd(ENABLE);
    399          }
    400          
    401          void ADC_Configuration(void)
    402          {
    403            /*  Init GPIO for ADC2 */
    404            //GPIO_Init(GPIOC, GPIO_PIN_4, GPIO_MODE_IN_FL_NO_IT);
    405            
    406            /* De-Init ADC peripheral*/
    407            ADC1_DeInit();
    408          
    409            /* Init ADC2 peripheral */
    410            ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS, ADC1_CHANNEL_2, ADC1_PRESSEL_FCPU_D18, \
    411                      ADC1_EXTTRIG_TIM, DISABLE, ADC1_ALIGN_LEFT, ADC1_SCHMITTTRIG_CHANNEL2,\
    412                      DISABLE);
    413            //ADC1->CSR |= 0x02;
    414            //ADC1->CR1 |= 0x52;
    415            //ADC1->CR3 |= 0x80;
    416              
    417          
    418            //ADC1->CR2 |= 0x0A;
    419            
    420            ADC1_StartConversion();
    421          
    422            /* Enable EOC interrupt */
    423            //ADC1_ITConfig(ADC1_IT_EOCIE, ENABLE);
    424            
    425            //Priority ITC_IRQ_ADC1
    426            //ITC_SetSoftwarePriority(ITC_IRQ_ADC1,ITC_PRIORITYLEVEL_3);
    427          
    428            /* Enable general interrupts */  
    429            //enableInterrupts();
    430            
    431            /*Start Conversion */
    432          }
    433          
    434          
    435          void TIM4_Configuration(void)
    436          {
    437            /* TIM4 configuration:
    438             - TIM4CLK is set to 16 MHz, the TIM4 Prescaler is equal to 128 so the TIM1 counter
    439             clock used is 16 MHz / 16 = 1 000 000 Hz
    440            - With 1 000 000 Hz we can generate time base:
    441                max time base is 0.256 ms if TIM4_PERIOD = 255 --> (255 + 1) / 1000000 = 32 us
    442                min time base is 0.002 ms if TIM4_PERIOD = 1   --> (  1 + 1) / 1000000 = 2 us
    443            - In this example we need to generate a time base equal to 125us
    444             so div 8 TIM4_PERIOD 100us = (0.0001 * 2000000 - 1) = 99 
    445            so div 4 TIM4_PERIOD 10us = (0.00001 * 4000000 - 1) = 39 */
    446          
    447            /* Time base configuration */
    448            TIM4_DeInit();
    449            TIM4_TimeBaseInit(TIM4_PRESCALER_8, 99); //50us
    450            //TIM4_TimeBaseInit(TIM4_PRESCALER_4, 39); //20us
    451            /* Clear TIM4 update flag */
    452            TIM4_ClearFlag(TIM4_FLAG_UPDATE);
    453            /* Enable update interrupt */
    454            TIM4_ITConfig(TIM4_IT_UPDATE, ENABLE);
    455            /* Enable TIM4 */
    456            TIM4_Cmd(ENABLE);
    457          }
    458          
    459          unsigned char RFID_FindStart(void)
    460          {
    461            if (ucEdgeCounter>=17) return 1;
    462            if (ucEdgeCounter >= ucTestMaxStartCounter) ucTestMaxStartCounter=ucEdgeCounter;
    463            if (ucCnt>=3 && ucCnt<7) ucDuration = 1;
    464            else if (ucCnt>=8 && ucCnt<12)ucDuration = 2;
    465            else 
    466            {
    467              RFID_Reset();
    468              ucDuration = 0;
    469            }
    470            ucCnt = 0;
    471            TIM4_SetCounter(0);
    472            //TEST_ON;
    473            if (ucEdgeCounter==0) 
    474            {
    475              //TEST_OFF;
    476              
    477              if (ucDuration==2 && !ucInputLevel) //High & Long
    478              {
    479                ucEdgeCounter=1;
    480                //Starts with LONG & HIGH always
    481                ucDurationFlag = 2;
    482              }
    483            }
    484            else if ((ucEdgeCounter%2))
    485            {
    486              if (ucDuration==1 && ucInputLevel) //Low & Short
    487              {
    488                ucEdgeCounter++;
    489              }
    490              else ucEdgeCounter=0;
    491            }
    492            else if (!(ucEdgeCounter%2))
    493            {
    494              if (ucDuration==1 && !ucInputLevel) //High & Short
    495              {
    496                ucEdgeCounter++;
    497              }
    498              else ucEdgeCounter=0;
    499            }
    500            return 0;
    501          }
    502          
    503          void RFID_GetData(void)
    504          {
    505            unsigned char update=0;
    506            //Оценка длительности импульса
    507            if (ucCnt>=3 && ucCnt<7) ucDuration = 1;
    508            else if (ucCnt>=8 && ucCnt<12) ucDuration = 2;
    509            else 
    510            {
    511              RFID_Reset();
    512              ucDuration = 0;
    513          
    514            }
    515            ucCnt = 0;
    516            TIM4_SetCounter(0);
    517          
    518            
    519            //Если Long&high -> ловим спады, записываем единицу в буфер
    520            //Если Long&Low -> ловим фронты, записываем 0 в буфер
    521            if (ucDuration==2) //Long
    522            {
    523              if (ucInputLevel) ucDurationFlag = 1; //now High level -> was Low level.
    524              else ucDurationFlag = 2; //&was High
    525            }
    526            
    527            if (ucInputLevel && ucDurationFlag==1) //now High, was Low -> Rise edge ==0
    528            {
    529              update= 1;
    530              ucDataBit=0;
    531            }
    532            if (!ucInputLevel && ucDurationFlag==2) 
    533            {
    534              update = 1;
    535              ucDataBit=1;
    536            }
    537            
    538            if (update)
    539            {
    540              update = 0;
    541              if (ucDataReceiveIndex && (ucDataReceiveIndex%5)==4)
    542              {
    543                if ((ucDataReceiveIndex/5)==10)
    544                {
    545                  //Full message received
    546                  //Row Parity check
    547                  if (ucRowParity != ucDataByte)
    548                  {
    549                    RFID_Reset();
    550                    return;
    551                  }
    552                  else
    553                  {
    554                    //Флаг переключения на передачу RFID в считыватель TM
    555                    flagRfidKeyCodeReady = 1;
    556                    //Сброс счетсчика импульсов наличия карты RFID
    557                    uiRfidPulsesCounter = 0;
    558                    //Флаг для ЧИРПа при первой передачи кода ТМ
    559                    flagRfidKeyCodeSendOk = 1;
    560                    //TIM4_DeInit();
    561                    //Combine Data
    562                    ucDataReceiveBuffer[9]=(ucDataReceiveBuffer[8]<<4) + ucDataReceiveBuffer[9];//TMP1->1
    563                    ucDataReceiveBuffer[8]=(ucDataReceiveBuffer[4]<<4) + ucDataReceiveBuffer[5];//TMP2->3
    564                    ucDataReceiveBuffer[4]=(ucDataReceiveBuffer[2]<<4) + ucDataReceiveBuffer[3];
    565                    ucDataReceiveBuffer[5]=(ucDataReceiveBuffer[0]<<4) + ucDataReceiveBuffer[1];
    566                    ucDataReceiveBuffer[2]=(ucDataReceiveBuffer[6]<<4) + ucDataReceiveBuffer[7];
    567                    ucDataReceiveBuffer[1]=ucDataReceiveBuffer[9];
    568                    ucDataReceiveBuffer[3]=ucDataReceiveBuffer[8];
    569                    ucDataReceiveBuffer[6]=0x00; //5
    570                    ucDataReceiveBuffer[0]=0x01; //FAMILY-CODE
    571                    ucDataReceiveBuffer[7]=CRC8(ucDataReceiveBuffer, 7); //CRC
    572                    
    573                    asm("NOP");
    574          
    575          
    576                  }
    577                }
    578                else
    579                {
    580                //String Parity check
    581                if (ucStringParity != ucDataBit)
    582                {
    583                  RFID_Reset();
    584                  return;
    585                }
    586                else
    587                {
    588                  ucStringParity = 0;
    589                  //Copy data to Buffer
    590                  ucDataReceiveBuffer[(ucDataReceiveIndex/5)]=ucDataByte;
    591                  //Row Parity calc
    592                  ucRowParity ^= ucDataByte;
    593                  //Clear DataRegister
    594                  ucDataByte = 0;
    595                }
    596                }
    597              }
    598              else
    599              {
    600                //GPIO_WriteHigh(GPIOB, GPIO_PIN_5);
    601                //Combine Bit to Byte
    602                ucDataByte <<= 1;
    603                ucDataByte |= ucDataBit;
    604                //String Parity calc
    605                ucStringParity ^= ucDataBit;
    606              }
    607              ucDataReceiveIndex++;
    608            }
    609          }
    610          
    611          
    612          
    613          
    614          unsigned char OWTM_SendData(unsigned char *OW_DataBuffer)
    615          {
    616            unsigned int OW_Timer=0;
    617            unsigned char OW_DataBits=0;
    618            unsigned char OW_DataByte=0;
    619            unsigned char OW_DataBytesCnt=0;
    620            //Запрет прерываний
    621            asm("NOP");
    622            disableInterrupts();
    623            asm("NOP");
    624            IWDG_ReloadCounter(); //Wath-dog reset
    625          
    626            
    627            
    628            OW_Timer = 0;
    629            while (!GPIO_ReadInputPin(GPIOC, GPIO_PIN_3) && (++OW_Timer<50000)) asm("NOP");
    630            if (OW_Timer >= 100)
    631            {
    632              
    633              //Формирование импульса PRESENCE
    634              
    635              //20us delay
    636              
    637              OW_Timer=20; while(OW_Timer--) asm("NOP");
    638              //Роняем шину к земле
    639              GPIO_WriteHigh(GPIOC,GPIO_PIN_4);
    640              //100us delay
    641              OW_Timer=150; while(OW_Timer--) asm("NOP");
    642              //поднимаем шину
    643              GPIO_WriteLow(GPIOC,GPIO_PIN_4);
    644              
    645              //Ждем возвращения линии в высокий уровень
    646              OW_Timer=50000;
    647              while(!GPIO_ReadInputPin(GPIOC, GPIO_PIN_3) && OW_Timer--) asm("NOP");
    648              asm("NOP");
    649              
    650              //Прием данных
    651              asm("NOP");
    652              while(OW_DataBits<8)
    653              {
    654                IWDG_ReloadCounter(); //Wath-dog reset
    655          
    656                //ждем спадающего фронта
    657                OW_Timer=50000;
    658                while(GPIO_ReadInputPin(GPIOC, GPIO_PIN_3) && OW_Timer--) asm("NOP");
    659                //Задержка 25мкс
    660                OW_Timer=25; while(OW_Timer--) asm("NOP");
    661              
    662                //Чтание бита данных
    663                if (GPIO_ReadInputPin(GPIOC, GPIO_PIN_3)) OW_DataByte |= (1<<OW_DataBits);
    664                
    665                //инкремент счетсчика битов
    666                OW_DataBits++;
    667                
    668                //Ждем возвращения линии в высокий уровень
    669                OW_Timer=50000;
    670                while(!GPIO_ReadInputPin(GPIOC, GPIO_PIN_3) && OW_Timer--) asm("NOP");
    671          
    672              }
    673              
    674              
    675              //Анализ принятого кода
    676              if (OW_DataByte == 0x33)
    677              {
    678                /* КОЛЛИЗИЯ: ЗДЕСЬ МОЖЕТ ЗАВИСНУТЬ ЕСЛИ КОНТРОЛЛЕР СЧИТАЛ НЕ ВСЕ БИТЫ */
    679                
    680                //Передача кода ключа
    681                //1-Wire отправляет код побитно с конца
    682                //8 байт данных
    683                OW_DataBytesCnt=0;
    684                while(OW_DataBytesCnt<8)
    685                {
    686                  //Отправка одного байта побитно
    687                  OW_DataBits=0;
    688                  while(OW_DataBits<8)
    689                  {
    690                    IWDG_ReloadCounter();                  //Wath-dog reset
    691                    
    692                    //Ждем спада фронта
    693                    OW_Timer=50000;
    694                    while(GPIO_ReadInputPin(GPIOC, GPIO_PIN_3) && OW_Timer--) asm("NOP");
    695                    
    696                    // если передаем единицу поднимаем уровень на 45мкс
    697                    //если передаем ноль - удерживаем низкий уровень в течении 45мкс
    698                    
    699                    if (!(OW_DataBuffer[OW_DataBytesCnt] & (1<<OW_DataBits))) GPIO_WriteHigh(GPIOC,GPIO_PIN_4);
    700                    
    701                    //Задержка 50мкс
    702                    OW_Timer=50; while(OW_Timer--) asm("NOP");
    703                    
    704                    //test
    705                    //GPIO_WriteLow(GPIOB,GPIO_PIN_5);
    706                    
    707                    //Отпускаем шину вверх
    708                    GPIO_WriteLow(GPIOC,GPIO_PIN_4);
    709                    
    710                    //Ждем возвращения линии в высокий уровень
    711                    OW_Timer=50000;
    712                    while(!GPIO_ReadInputPin(GPIOC, GPIO_PIN_3) && OW_Timer--) asm("NOP");
    713                    OW_DataBits++;
    714                  }
    715                  
    716                  OW_DataBytesCnt++;
    717                }
    718                asm("NOP"); //Передача данных завершена
    719                //Ждем возвращения линии в высокий уровень
    720                OW_Timer=50000;
    721                while(!GPIO_ReadInputPin(GPIOC, GPIO_PIN_3) && OW_Timer--) asm("NOP");
    722                return 1;
    723              }
    724              
    725            }
    726          
    727            //Ждем возвращения линии в высокий уровень
    728            OW_Timer=50000;
    729            while(!GPIO_ReadInputPin(GPIOC, GPIO_PIN_3) && OW_Timer--) asm("NOP");
    730            return 0;
    731          }
    732          
    733          
    734          
    735          
    736          void RFID_Reset(void)
    737          {
    738            ucEdgeCounter=0;
    739            ucRowParity=0;
    740            ucStringParity=0;
    741            ucDataByte=0;
    742            ucDataReceiveIndex=0;
    743            ucCnt=0;
    744          }
    745          
    746          
    747          /* Подсчет CRC8 массива mas длиной Len */
    748          unsigned char CRC8( unsigned char *mas, unsigned char Len )
    749          {
    750            unsigned char i,dat,crc,fb,st_byt;
    751            st_byt=0; crc=0;
    752            do{
    753              dat=mas[st_byt];
    754              for( i=0; i<8; i++) {  // счетчик битов в байте
    755                fb = crc ^ dat;
    756                fb &= 1;
    757                crc >>= 1;
    758                dat >>= 1;
    759                if( fb == 1 ) crc ^= 0x8c; // полином
    760              }
    761              st_byt++;
    762            } while( st_byt < Len ); // счетчик байтов в массиве
    763            return crc;
    764          }
    765          
    766          
    767          void BuzzerChirp(void)
    768          {
    769            unsigned int duration=0, tone=0;
    770          
    771            
    772            GPIO_WriteLow(GPIOC, GPIO_PIN_6);
    773            GPIO_WriteLow(GPIOC, GPIO_PIN_5);
    774            //F=4kHz
    775            duration = 400;
    776            while(duration--)
    777            {
    778              //Wath-dog reset
    779              IWDG_ReloadCounter();
    780              
    781              GPIO_WriteLow(GPIOC, GPIO_PIN_5);
    782              GPIO_WriteHigh(GPIOC, GPIO_PIN_6);
    783              tone = 150; while(tone--) asm("NOP");
    784              GPIO_WriteLow(GPIOC, GPIO_PIN_6);
    785              GPIO_WriteHigh(GPIOC, GPIO_PIN_5);
    786              tone = 150; while(tone--) asm("NOP");
    787            }
    788            
    789            
    790            //Off Pins
    791            GPIO_WriteLow(GPIOC, GPIO_PIN_6);
    792            GPIO_WriteLow(GPIOC, GPIO_PIN_5);
    793          
    794          }
    795          
    796          void BuzzerStart(void)
    797          {
    798          
    799            unsigned int DelaySound;
    800            unsigned char ucDelaySound2;
    801            disableInterrupts();
    802            ucDelaySound2 = 40;
    803            while(ucDelaySound2--) 
    804            {
    805              DelaySound=50000; while (DelaySound--) ;
    806            }
    807            
    808          //RUSSIAN GIMN!!!
    809            //G 0.5 3136 Hz
    810            BuzzerSound(3136, 10);
    811            DelaySound=2000; while (DelaySound--) ;
    812            //C 1.0 4186 Hz
    813            BuzzerSound(4186, 20);
    814            DelaySound=4000; while (DelaySound--) ;
    815            //G 0.5 3136 Hz
    816            BuzzerSound(3136, 10);
    817            DelaySound=2000; while (DelaySound--) ;
    818            //A 0.25 3440 Hz
    819            BuzzerSound(3440, 5);
    820            DelaySound=1000; while (DelaySound--) ;
    821            //B 0.5 3951 Hz
    822            BuzzerSound(3951, 10);
    823            DelaySound=1000; while (DelaySound--) ;
    824            /*
    825            //E 0.5 2637 Hz
    826            BuzzerSound(2637, 10);
    827            DelaySound=2000; while (DelaySound--) ;
    828            //E 0.5 2637 Hz
    829            BuzzerSound(2637, 10);
    830            DelaySound=2000; while (DelaySound--) ;
    831            //A 1.0 3440 Hz
    832            BuzzerSound(3440, 20);
    833            DelaySound=4000; while (DelaySound--) ;
    834            //G 0.5 3136 Hz
    835            BuzzerSound(3136, 10);
    836            DelaySound=2000; while (DelaySound--) ;
    837            //F 0.25 2793 Hz
    838            BuzzerSound(2793, 5);
    839            DelaySound=1000; while (DelaySound--) ;
    840            //G 0.5 3136 Hz
    841            //G 0.5 3136 Hz
    842            BuzzerSound(3136, 10);
    843            DelaySound=2000; while (DelaySound--) ;
    844            */
    845            enableInterrupts();
    846          
    847          }
    848          
    849          
    850          void IWDG_Configuration(void)
    851          {
    852            IWDG_Enable();
    853            IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
    854            IWDG_SetPrescaler(IWDG_Prescaler_256);
    855            IWDG_SetReload(0xFF);
    856            
    857            IWDG_WriteAccessCmd(IWDG_WriteAccess_Disable);
    858          }
    859          void BuzzerSound(unsigned int freq, unsigned int delay)
    860          {
    861            unsigned int duration=0;
    862            unsigned long tone=0;
    863          
    864            //F=4kHz - 150
    865            //2000 - 300
    866            while(delay--)
    867            {
    868            duration = freq/300;
    869            while(duration--)
    870            {
    871              GPIO_WriteLow(GPIOC, GPIO_PIN_5);
    872              GPIO_WriteHigh(GPIOC, GPIO_PIN_6);
    873              tone = 600000 / freq; while(tone--) asm("NOP");
    874              GPIO_WriteLow(GPIOC, GPIO_PIN_6);
    875              GPIO_WriteHigh(GPIOC, GPIO_PIN_5);
    876              tone = 600000 / freq; while(tone--) asm("NOP");
    877            }
    878            }
    879            
    880            
    881            //Off Pins
    882            GPIO_WriteLow(GPIOC, GPIO_PIN_6);
    883            GPIO_WriteLow(GPIOC, GPIO_PIN_5);
    884          }
    885          
    886          
    887          
    888          
    889          /****************** INTERRUPTS ******************************/
    890          
    891          
    892          #pragma vector=7 //особенность IAR - номер_вектора = номер_по_документации_ST + 2 //PC4 EXTI2 PORTC Vector=5;
    893          __interrupt void EMMarineDataReceive(void)
    894          {
    895          }
    896          
    897          
    898          #pragma vector=13 //особенность IAR - номер_вектора = номер_по_документации_ST + 2
    899          __interrupt void TIM1_Update(void)
    900          {
    901            //GPIO_WriteReverse(GPIOB, GPIO_PIN_5);
    902            /* Cleat Interrupt Pending bit */
    903            TIM1_ClearITPendingBit(TIM1_IT_UPDATE);
    904          }
    905          
    906          #pragma vector=14 //Timer2 Copmare2
    907          __interrupt void TIM2_CC2(void)
    908          {
    909          
    910          
    911            /* Cleat Interrupt Pending bit */
    912            TIM2_ClearITPendingBit(TIM2_IT_CC2);
    913          }
    914          
    915          
    916          #pragma vector = 24 //INTERRUPT_HANDLER(ADC1_IRQHandler, 22) ITC_IRQ_ADC1
    917          __interrupt void ADC1_ConversationComplete(void)
    918          {
    919            ADC1_ITConfig(ADC1_IT_EOCIE, DISABLE);
    920          }
    921          
    922          
    923          #pragma vector=25 //особенность IAR - номер_вектора = номер_по_документации_ST + 2
    924          __interrupt void TIM4_ReceiveDataTimer(void)
    925          {
    926            //Если карты нет или код "смазанный" - готовимся к считываюнию заново
    927          
    928            if (ucCnt<200) ucCnt++;
    929            //isRfidFreqChangeEnable = 1;
    930            
    931            /*if (uiRfidFreqCnt == 0) 
    932            {
    933              isRfidFreqStart = 1;
    934              uiRfidFreqCnt = 1;
    935            }
    936            else if (uiRfidFreqCnt>5000) uiRfidFreqCnt = 0;
    937            else if (++uiRfidFreqCnt==1500) isRfidFreqStop = 1;*/
    938            
    939            
    940            /* Cleat Interrupt Pending bit */
    941            TIM4_ClearITPendingBit(TIM4_IT_UPDATE);
    942          }
    943          
    944          
    945          
    946          
    947          #ifdef USE_FULL_ASSERT
    948          
    949          /**
    950            * @brief  Reports the name of the source file and the source line number
    951            *   where the assert_param error has occurred.
    952            * @param file: pointer to the source file name
    953            * @param line: assert_param error line source number
    954            * @retval None
    955            */
    956          void assert_failed(u8* file, u32 line)
    957          { 
    958            /* User can add his own implementation to report the file name and line number,
    959               ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    960          
    961            /* Infinite loop */
    962            while (1)
    963            {
    964            }
    965          }
    966          #endif
    967          
    968          
    969          

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      26  ADC1_ConversationComplete
      32  ADC_Configuration
     135  BuzzerChirp
     191  BuzzerSound
     185  BuzzerStart
       5  CLK_Configuration
      90  CRC8
       1  EMMarineDataReceive
      99  GPIO_Configuration
      23  IWDG_Configuration
     522  OWTM_SendData
     204  RFID_FindStart
     394  RFID_GetData
      25  RFID_Reset
       1  RFID_crc8
      34  TIM1_Configuration
      24  TIM1_Update
      24  TIM2_CC2
      32  TIM2_Configuration
      32  TIM4_Configuration
      39  TIM4_ReceiveDataTimer
       1  flagEnableTM_DisableRFID
       1  flagRfidKeyCodeReady
       1  flagRfidKeyCodeSendOk
       1  flagRfidPinOldState
       1  isRfedFreqEnable
       1  isRfidFreqStart
       1  isRfidFreqStop
     215  main
       1  ucCnt
       1  ucDataBit
       1  ucDataByte
      11  ucDataReceiveBuffer
       1  ucDataReceiveIndex
       1  ucDuration
       1  ucDurationFlag
       1  ucEdgeCounter
       1  ucInputLevel
      11  ucOldKeyCode
       1  ucRowParity
       1  ucStringParity
       1  ucTestMaxStartCounter
       2  uiKeyCodeResetTimer
       1  uiOWCountEnable
       2  uiOWTimer
       2  uiRfidFreqCnt
       2  uiRfidPulsesCounter

 
    50 bytes in section .near.bss
 2 332 bytes in section .near_func.text
 
 2 332 bytes of CODE memory
    50 bytes of DATA memory

Errors: none
Warnings: none
