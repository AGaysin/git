unsigned char disk_initialize(){
  
    int u = 0;
    delay_ms(250);
    GPIO_WriteHigh(GPIOC, GPIO_PIN_3);
    
    for (u = 0; u < 10; u++) {
        SPI_SendByte(0xff);
    }
    
    GPIO_WriteLow(GPIOC, GPIO_PIN_3);
    SPI_SendByte(0xff);
    SPI_SendByte(0xff);
    delay_ms(1);
    
    //CMD0 - —брос карты и перевод в режим работы по SPI - ответ 0x01;
    command(0,0,0x95);
    count = 0;
    while ((SPI_ReadByte() != 1) && (count < 1000)) count++;
    if (count >= 1000) {
        //string("CARD ERROR-CMD0 ",1);
        delay_ms(500);
        return 1;
    }
    
    
    //CMD8 - ѕроверка версии карты, если ответ 0x01 - SD v.2. ≈сли 0x04 (com are error) - SD v.1
    command(8,0x1AA,0x87);
    count = 0;
    //Check card version, R7
    unsigned char SPI_answer=0;
    while ((SPI_answer != 1) && (SPI_answer != 4) && (count < 1000)) 
    {
      SPI_answer = SPI_ReadByte();
      count++;
    }
    
    
    if (SPI_answer==0x01) // арта нова€, >= v.2
    {
      
    //Check Voltage R7
    while ((SPI_ReadByte() != 0x01) && (count < 1000)) count++;
    //Check pattern R7
    while ((SPI_ReadByte() != 0xAA) && (count < 1000)) count++;
    if (count >= 1000) {
        //string("CARD ERROR-CMD8 ",1);
        delay_ms(500);
        return 1;
      }
      
      do
      {
      //«ацикливаем команду ACMD41 = CMD55 + CMD41 до тех пор, пока карта не будет готова (ответ 0)
      //CMD55 c пустым аргументом и любым CRC, ответ 0x01
      command(55,0,0xFF);
      count = 0;
      while ((SPI_ReadByte() != 1) && (count < 1000)) count++;
      if (count >= 1000) {
        //string("CARD ERROR-CMD1 ",1);
        delay_ms(500);
        return 1;
      }
      
      //CMD41
      command(41,(unsigned long)1 << 30,0xFF);
      count = 0;
      SPI_answer = 0xFF;
      while ((SPI_answer != 0) && (SPI_answer != 1) && (count < 1000)) 
      {
        SPI_answer = SPI_ReadByte();
        count++;
      }
      if (count>= 1000)
      {
        delay_ms(500);
        return 1;
      }
    }while (SPI_answer!=0); //idle_state=0;
      
      //CMD58
      command(58,0,0xFF);
      count = 0;
      while ((SPI_ReadByte() != 0) && (count < 1000)) count++; //R1 - idle state off  R1==0
      if (count >= 1000) {
        //string("CARD ERROR-CMD1 ",1);
        delay_ms(500);
        return 1;
      }
      //ѕроверка CSS/HCS в OCR - типа пам€ть High Capacity или обычна€
      //в HC чтение идет всегда блоками по 512. в CS - нужно указать что размер блока 512
      SPI_answer = SPI_ReadByte(); //OCR4
      SPI_ReadByte();   //OCR3
      SPI_ReadByte();   //OCR2
      SPI_ReadByte();   //OCR1
      SPI_ReadByte();   //OCR0
      if (!(SPI_answer & (1<<6))) //≈сли карта пам€ти не HSC - нужно указать размер блока 
      {
        //CMD16
        command(16,512,0xFF);
        count = 0;
        while ((SPI_ReadByte() != 0) && (count < 1000)) count++; //R1 - idle state off  R1==0
        if (count >= 1000) {
          //string("CARD ERROR-CMD1 ",1);
          delay_ms(500);
          return 1;
        }
        
        
        
      }
      
       
       
        
        
    }
    else if (SPI_answer==0x04) // арта стара€, v.1
    {
      asm("NOP");
      //CMD1
      SPI_SendByte(0xFF);
      SPI_SendByte(0x41);
      SPI_SendByte(0x00);
      SPI_SendByte(0x00);
      SPI_SendByte(0x00);
      SPI_SendByte(0x00);
      SPI_SendByte(0xFF);
      count = 0;
      while ((SPI_ReadByte() != 0) && (count < 1000)) count++;
      if (count>= 1000)
      {
        delay_ms(500);
        return 1;
      }
      
      //CMD16
      SPI_SendByte(0xFF);        
      SPI_SendByte(0x40 + 16);//COM
      SPI_SendByte(0x00);//DATA0
      SPI_SendByte(0x00);//DATA1
      SPI_SendByte(0x02);//DATA2
      SPI_SendByte(0x00);//DATA3
      SPI_SendByte(0xFF);//CRC
      count = 0;
      while ((SPI_ReadByte() != 1) && (count < 1000)) count++;
      if (count>= 1000)
      {
        delay_ms(500);
        return 1;
      }
    }
       
    //string("MMC INITIALIZED!",1);
    //GPIO_WriteHigh(GPIOC, GPIO_PIN_3);
    delay_ms(500);
    //SPCR &= ~(1<<SPR1); //increase SPI clock from f/32 to f/2
    return 0;
}